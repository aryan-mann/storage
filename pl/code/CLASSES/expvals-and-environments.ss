#!r7rs

;;; Expressed values and environments for CLASSES

;;; John David Stone
;;; Department of Computer Science
;;; Grinnell College

;;; created April 26, 2009
;;; last revised August 1, 2019

;;; This library defines a data type
;;; for expressed values of the CLASSES programming language,
;;; as described in section 9.3 of
;;; _Essentials of programming languages_, third edition
;;; (Cambridge, Massachusetts: The MIT Press, 2008; ISBN 978-0-262-06279-4),
;;; by Daniel P. Friedman and Mitchell Wand.
;;; It also defines simple environments,
;;; as described in section 2.2 of that book,
;;; and a global environment for class names.
;;; These datatypes are presented together
;;; because they are mutually recursive.

(define-library (CLASSES expvals-and-environments)
  (export expval? num-val bool-val proc-val list-val object-val
          expval->num expval->bool expval->proc expval->elements expval->obj
          proc? a-proc
          environment? empty-env extend-env extend-env-rec
          extend-env-with-self-and-super apply-env init-env
          object? an-object object->class-name object->fields new-object
          method? a-method
          class? a-class initialize-class-env! find-method)
  (import (scheme base)
          (scheme char)
          (srfi list-lib)
          (utilities eopl)
          (CLASSES syntax-trees)
          (CLASSES stores))
  (begin

    ;; An expressed value in CLASSES
    ;; is either an exact integer, a Boolean,
    ;; a value of the proc (i.e., closure) data type defined below,
    ;; a list,
    ;; or an object (i.e., a value of the object data type defined below).

    (define-datatype expval expval?
      (num-val (num exact-integer?))
      (bool-val (bool boolean?))
      (proc-val (proc proc?))
      (list-val (elements (list-of expval?)))
      (object-val (obj object?)))

    ;; We supplement the data type interface
    ;; with projection functions that recover the values
    ;; stored in the respective fields of the variants.

    ;; expval->num : ExpVal -> Int

    (define expval->num
      (lambda (val)
        (cases expval val
          (num-val (num) num)
          (else (report-expval-extraction-error 'num val)))))

    ;; report-expval-extraction-error : Symbol * ExpVal -> (aborts the computation)

    (define report-expval-extraction-error
      (lambda (bad-type bad-ev)
        (eopl:error (string->symbol
                      (string-append "expval->"
                                     (symbol->string bad-type)))
                    "undefined for expressed value ~a~%"
                    bad-ev)))

    ;; expval->bool : ExpVal -> Bool

    (define expval->bool
      (lambda (val)
        (cases expval val
          (bool-val (bool) bool)
          (else (report-expval-extraction-error 'bool val)))))

    ;; expval->proc : ExpVal -> Proc

    (define expval->proc
      (lambda (val)
        (cases expval val
          (proc-val (proc) proc)
          (else (report-expval-extraction-error 'proc val)))))

   ;; expval->elements : ExpVal -> ListOf(ExpVal)

    (define expval->elements
      (lambda (val)
        (cases expval val
          (list-val (elements) elements)
          (else (report-expval-extraction-error 'elements val)))))

   ;; expval->obj : ExpVal -> Object

    (define expval->obj
      (lambda (val)
        (cases expval val
          (object-val (obj) obj)
          (else (report-expval-extraction-error 'obj val)))))

    ;; The identifiers used in this data type definition
    ;; differ slightly from those used in Friedman and Wand's book,
    ;; to avoid conflicts with standard Scheme's built-in procedure? procedure.

    (define-datatype proc proc?
      (a-proc (parameters (list-of identifier?))
              (body expression?)
              (saved-env environment?)))

    ;; An environment is either empty
    ;; or extends another environment by adding new variables
    ;; to which newly allocated storage locations are bound.

    ;; The names of fields in a method
    ;; can be symbols that are generated by the fresh-identifier procedure.
    ;; These symbols contain percentage signs
    ;; and so are not technically identifiers,
    ;; which is why the type constraint on vars
    ;; is (list-of extended-identifier?) rather than (list-of identifier?).

    (define-datatype environment environment?
      (empty-env)
      (extend-env
        (vars (list-of extended-identifier?))
        (loc (list-of reference?))
        (saved environment?))
      (extend-env-rec
        (p-names (list-of identifier?))
        (p-lists (list-of (list-of identifier?)))
        (bodies (list-of expression?))
        (saved environment?))
      (extend-env-with-self-and-super
        (self object?)
        (super-name identifier?)
        (saved environment?)))

    (define extended-identifier?
      (lambda (something)
        (and (symbol? something)
             (let ((letter-list (string->list (symbol->string something))))
               (and (pair? letter-list)
                    (char-alphabetic? (car letter-list))
                    (every (lambda (letter)
                             (or (char-alphabetic? letter)
                                 (char-numeric? letter)
                                 (char=? letter #\-)
                                 (char=? letter #\?)
                                 (char=? letter #\%)))
                           (cdr letter-list)))))))

    ;; The apply-env procedure looks up a given identifier or pseudo-identifier
    ;; in a given environment
    ;; and returns the storage location, object, or identifier bound to it.
    ;; It is an error to apply apply-env
    ;; to an identifier that is not bound in the given environment.

    ;; apply-env : Env * ExtendedIdentifier -> SchemeVal

    (define apply-env
      (lambda (env sought)
        (let kernel ((remaining env))
          (cases environment remaining
            (empty-env ()
              (report-no-binding-found sought env))
            (extend-env (vars locs saved)
              (let inner-loop ((rest-of-vars vars)
                               (rest-of-locs locs))
                (cond ((null? rest-of-vars) (kernel saved))
                      ((eqv? (car rest-of-vars) sought) (car rest-of-locs))
                      (else (inner-loop (cdr rest-of-vars) (cdr rest-of-locs))))))
            (extend-env-rec (p-names p-lists bodies saved)
              (let inner-loop ((rest-of-p-names p-names)
                               (rest-of-p-lists p-lists)
                               (rest-of-bodies bodies))
                (cond ((null? rest-of-p-names) (kernel saved))
                      ((eqv? sought (car rest-of-p-names))
                       (newref (proc-val (a-proc (car rest-of-p-lists)
                                                 (car rest-of-bodies)
                                                 remaining))))
                      (else (inner-loop (cdr rest-of-p-names)
                                        (cdr rest-of-p-lists)
                                        (cdr rest-of-bodies))))))
            (extend-env-with-self-and-super (self super-name saved)
              (case sought
                ((%self) self)
                ((%super) super-name)
                (else (kernel saved))))))))

    (define report-no-binding-found
      (lambda (sought env)
        (eopl:error 'apply-env
                    "No binding for ~s was found in environment ~s.~%"
                    sought
                    env)))

    ;; CLASSES programs are evaluated
    ;; in an empty initial environment
    ;; The init-env procedure constructs and returns this environment.

    ;; init-env : () -> Env

    (define init-env
      (lambda ()
        (empty-env)))

    ;; An object comprises the name of its class
    ;; and a list of references to storage locations,
    ;; one for each field of the object.

    (define-datatype object object?
      (an-object (class-name identifier?)
                 (fields (list-of reference?))))

    ;; object->class-name : Obj -> Identifier

    (define object->class-name
      (lambda (obj)
        (cases object obj
          (an-object (class-name fields) class-name))))

    ;; object->fields : Obj -> Listof(Reference)

    (define object->fields
      (lambda (obj)
        (cases object obj
          (an-object (class-name fields) fields))))

    ;; new-object : Identifier -> Obj

    (define new-object
      (lambda (class-name)
        (an-object class-name
          (map (lambda (field-name)
                 (newref (list 'uninitialized-field field-name)))
               (class->field-names (lookup-class class-name))))))

    ;; A method comprises its parameter list,
    ;; its body (as an expression),
    ;; the name of the superclass of the class to which it belongs,
    ;; and the names of the fields of that class.
    ;; (A superclass always exists,
    ;; because in CLASSES the class at the root of the hierarchy
    ;; has no methods.)

    (define-datatype method method?
      (a-method (parameters (list-of identifier?))
                (body expression?)
                (super-name identifier?)
                (field-names (list-of extended-identifier?))))

    ;; A class comprises the name of the superclass of the class
    ;; (or #f, if no such superclass exists),
    ;; the names of the fields of objects of the class,
    ;; and a method environment, that is,
    ;; a lookup table for methods of the class.

    (define-datatype class class?
      (a-class (super-name (maybe identifier?))
               (field-names (list-of extended-identifier?))
               (method-env method-environment?)))

    ;; class->super-name : Class -> Identifier

    (define class->super-name
      (lambda (cl)
        (cases class cl
          (a-class (super-name field-names method-env) super-name))))

    ;; class->field-names : Class -> Listof(Sym)

    (define class->field-names
      (lambda (cl)
        (cases class cl
          (a-class (super-name field-names method-env) field-names))))

    ;; class->method-env : Class -> MethodEnv

    (define class->method-env
      (lambda (cl)
        (cases class cl
          (a-class (super-name field-names method-env) method-env))))

    ;;; A method environment is simply a list of two-element lists,
    ;;; each containing the name of a method and the method itself.

    ;; method-environment? : SchemeVal -> Bool

    (define method-environment?
      (list-of (lambda (element)
                (and (pair? element)
                     (identifier? (car element))
                     (pair? (cdr element))
                     (method? (cadr element))
                     (null? (cddr element))))))

    ;; We build a method environment
    ;; from the method's declarations,
    ;; together with the name of the superclass
    ;; of the class to which it belongs
    ;; and the names of the fields of the class to which it belongs.

    ;; method-decls->method-env :
    ;;     Listof(MethodDecl) * Identifier * Listof(Identifier) -> MethodEnv

    (define method-decls->method-env
      (lambda (m-decls super-name field-names)
        (map (lambda (m-decl)
               (cases method-declaration m-decl
                 (a-method-declaration (method-name parameters body)
                   (list method-name
                         (a-method parameters body super-name field-names)))))
             m-decls)))

    ;;; The initialize-class-env! procedure
    ;;; puts a program's class declarations
    ;;; into the global class environment,
    ;;; represented here as a list of two-element lists,
    ;;; each containing the name of a class and the class itself.

    ;; the-class-env : ClassEnv

    (define the-class-env '())

    ;; initialize-class-env! : Listof(ClassDecl) -> Unspecified

    (define initialize-class-env!
      (lambda (c-decls)
        (set! the-class-env (list (list 'object (a-class #f '() '()))))
        (for-each initialize-class-decl! c-decls)))

    ;; initialize-class-decl! : ClassDecl -> Unspecified

    (define initialize-class-decl!
      (lambda (c-decl)
        (cases class-declaration c-decl
          (a-class-declaration (class-name super-name field-names method-decls)
            (let ((revised-field-names
                    (append-field-names (class->field-names 
                                          (lookup-class super-name))
                                        field-names)))
              (add-to-class-env!
                class-name
                (a-class super-name
                         revised-field-names
                         (merge-method-envs
                           (class->method-env (lookup-class super-name))
                           (method-decls->method-env
                             method-decls
                             super-name
                             revised-field-names)))))))))

    ;; append-field-names : Listof(Identifier) * Listof(Identifier) -> Listof(Identifier)

    (define append-field-names
      (lambda (super-fields new-fields)
        (if (null? super-fields)
            new-fields
            (cons (if (memq (car super-fields) new-fields)
                      (fresh-identifier (car super-fields))
                      (car super-fields))
                  (append-field-names (cdr super-fields) new-fields)))))

    ;; fresh-identifier : Sym -> Sym

    (define fresh-identifier
      (let ((counter 0))
        (lambda (base)
          (set! counter (+ counter 1))
          (string->symbol (string-append (symbol->string base)
                                         "%"
                                         (number->string counter))))))

    ;; add-to-class-env! : Sym * Class -> Unspecified

    (define add-to-class-env!
      (lambda (class-name class)
        (set! the-class-env (cons (list class-name class) the-class-env))))

    ;; lookup-class : Sym -> Class

    (define lookup-class
      (lambda (name)
        (let ((maybe-pair (assq name the-class-env)))
          (if maybe-pair
              (cadr maybe-pair)
              (report-nonexistent-class-error name)))))

    (define report-nonexistent-class-error
      (lambda (bad-class-name)
        (eopl:error 'lookup-class
                    "~s is not the name of a class.~%"
                    bad-class-name)))

    ;; The find-method performs a lookup in the class environment
    ;; and then in that class's method environment.

    ;; find-method : Sym * Sym -> Method

    (define find-method
      (lambda (c-name name)
        (let ((m-env (class->method-env (lookup-class c-name))))
          (let ((maybe-pair (assq name m-env)))
            (if (pair? maybe-pair)
                (cadr maybe-pair)
                (report-nonexistent-method-error name c-name))))))

    (define report-nonexistent-method-error
      (lambda (method-name class-name)
        (eopl:error 'find-method
                    "There is no method named ~s in class ~s.~%"
                    method-name
                    class-name)))

    ;; merge-method-envs : MethodEnv * MethodEnv -> MethodEnv

    (define merge-method-envs
      (lambda (super-m-env new-m-env)
        (append new-m-env super-m-env)))))

;;; These definitions are derived from similar work
;;; by Daniel P. Friedman (dfried@cs.indiana.edu)
;;; and Mitchell Wand (wand@ccs.neu.edu),
;;; who made them available as part of the Git repository
;;; at https://github.com/mwand/eopl3,
;;; under the Creative Commons Attribution-Noncommercial 3.0 Unported license
;;; (http://creativecommons.org/licenses/by-nc/3.0/).

;;; These specific versions,
;;; the implementations of the supplementary procedures,
;;; and the port to R7RS Scheme
;;; are copyright (C) 2009, 2015, 2019 by John David Stone
;;; and are similarly licensed
;;; under the Creative Commons Attribution-Noncommercial 3.0 Unported license.
